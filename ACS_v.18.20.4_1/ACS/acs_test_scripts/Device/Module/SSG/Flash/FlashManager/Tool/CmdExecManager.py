"""

:copyright: (c)Copyright 2013, Intel Corporation All Rights Reserved.
The source code contained or described here in and all documents related
to the source code ("Material") are owned by Intel Corporation or its
suppliers or licensors. Title to the Material remains with Intel Corporation
or its suppliers and licensors. The Material contains trade secrets and
proprietary and confidential information of Intel or its suppliers and
licensors.

The Material is protected by worldwide copyright and trade secret laws and
treaty provisions. No part of the Material may be used, copied, reproduced,
modified, published, uploaded, posted, transmitted, distributed, or disclosed
in any way without Intel's prior express written permission.

No license under any patent, copyright, trade secret or other intellectual
property right is granted to or conferred upon you by disclosure or delivery
of the Materials, either expressly, by implication, inducement, estoppel or
otherwise. Any license under such intellectual property rights must be express
and approved by Intel in writing.

:organization: INTEL MCG PSI
:summary: This file implements a class which allow local cmd execution in a Thread and monitor the its cmd output
:since: 09/07/2013
:author: lbavois
"""
import Queue
import threading
import time

from UtilitiesFWK.Utilities import run_local_command
from Core.Report.ACSLogging import LOGGER_TEST_SCRIPT


class CmdExecManager(object):

    """
    This class allows to launch a local cmd in a Thread and monitor the execution cmd output
    """

    def __init__(self, thread_name, logger=None):
        """
        Constructor

        :type thread_name: str
        :param thread_name: Name of the thread associated to command execution
        :type logger: object
        :param logger: logger name to log info
        """
        self._logger = logger if logger else LOGGER_TEST_SCRIPT
        self._proc = None
        self._exec_thread = None
        self._timeout = 0
        self._threadname = thread_name

    def _get_cmd(self):
        """
        Get the command to execute
        """
        return None

    def _start(self, timeout, execute_in_thread=False):
        """
        Start command execution in an independant thread or not
        """
        self._timeout = timeout
        if execute_in_thread:
            # Run the cmd in a dedicated thread
            self._exec_thread = threading.Thread(target=self._run)
            self._exec_thread.name = self._threadname
            self._exec_thread.daemon = True
            self._exec_thread.start()
        else:
            # Run the command
            self._run()

    def _stop(self):
        """
        Stop command execution
        """
        if self._proc is not None and self._proc.poll() is None:
            # Process is still running => terminate it
            self._proc.terminate()
            if self._logger:
                self._logger.debug("CmdExecManager: Terminate " + self._threadname + " thread execution")
            self._proc = None
        self._exec_thread = None

    def _dequeue(self, q):
        """
        Dequeue the stdout generated by command execution
        """
        data_list = []
        qsize = q.qsize
        while qsize > 0:
            try:
                data = unicode(q.get_nowait())
                data = data.strip('\n')
                data_list.append(data)
                qsize = q.qsize
            except Queue.Empty:
                break
            except UnicodeDecodeError:
                pass
        return data_list

    def _analyze_output(self, data):
        """
        Analyze stdout generated by command execution
        """
        pass

    def _run(self):
        """
        Execute command line
        """
        self._proc = None
        return_code = None
        error_message = ""

        try:
            cmd = self._get_cmd()
            if self._logger:
                self._logger.debug("Execute: %s" % cmd)
            self._proc, q = run_local_command(cmd)

            timeout = float(self._timeout)
            while timeout > 0 and self._proc is not None and self._proc.poll() is None:
                # pylint: disable=C0103
                # Agree to keep t0 & t1 variable names
                t0 = time.time()
                time.sleep(0.2)
                t1 = time.time()
                timeout -= (t1 - t0)
                stdout_data_list = self._dequeue(q)
                self._analyze_output(stdout_data_list)

            if timeout <= 0:
                # Timeout terminated
                error_message = "CmdExecManager: Timeout while command execution (%s)!" % cmd
            else:
                # Process terminated
                # Get return code
                if self._proc is not None:
                    return_code = self._proc.poll()
                    # assume that return code of application is UNIX
                    # so valid range is 0-255
                    # check that return code is valid
                    if return_code > 255 or return_code < 0:
                        # consider return code as invalid
                        return_code = None

                # Execution ends without exception
                if return_code is None:
                    error_message = "CmdExecManager: unexpected error with thread execution (cmd= %s )" % cmd

        except Exception as ex:  # pylint: disable=W0703
            error_message = "CmdExecManager: unexpected exception with thread execution (cmd= %s), error= %s" % (
                cmd, str(ex))

        finally:
            self._stop()

            if self._logger:
                self._logger.debug("CmdExecManager: execution terminated (return_code=%s, error_message=%s)" %
                                   (str(return_code), error_message))

            # Return ouput datas
            return return_code, error_message
